using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class WorldGenerator : MonoBehaviour
{

  private static WorldGenerator _instance;
  public static WorldGenerator Instance { get { return _instance; } }
  public int worldSeed = 0;
  public Vector2Int randomOffset; //Generated by random seed.
  public TextMeshProUGUI debugText;
  public PlayerController player;
  public float seaHeight = 45;

  //contains all chunks
  GameObject chunkMaster;

  public GameObject MarchingCubePrefab;
  public int viewDistanceMin = 256;
  public int viewDistanceMax = 256;
  public bool smoothTerrain = true;

  public GameObject WaterPrefab;
  private GameObject waterObject;

  // our textures
  public Texture2DArray terrainTexArray;
  public Texture2D[] terrainTextures;

  // what need to build?
  List<Vector2> buildList = new List<Vector2>();
  Vector3Int playerInChunk;

  List<Vector2> createdList = new List<Vector2>();
  List<Marching> chunkList = new List<Marching>();


  private void Awake()
  {
    if (_instance != null && _instance != this)
      Destroy(this.gameObject);
    else
      _instance = this;

    PopulateTextureArray();
  }

  void OnDrawGizmosSelected()
  {
    Gizmos.color = new Color(1, 0.8f, 0, 0.2f);
    Vector3 p;
    Vector3 s = new Vector3(MarchingData.width, MarchingData.height, MarchingData.width);
    for (int i = 0; i < buildList.Count; i++)
    {
      p = new Vector3(buildList[i].x, 0, buildList[i].y) + (s / 2);
      Gizmos.DrawCube(p, s);
    }

    Gizmos.color = new Color(0, 0.8f, 2, 0.2f);
    for (int i = 0; i < createdList.Count; i++)
    {
      p = new Vector3(createdList[i].x, 0, createdList[i].y) + (s / 2);
      Gizmos.DrawCube(p, s);
    }

  }

  // Start is called before the first frame update
  void Start()
  {
    chunkMaster = GameObject.Find("Chunks");
    Random.InitState(worldSeed);
    randomOffset.x = Random.Range(0, 65000);
    randomOffset.y = Random.Range(0, 65000);

    debugText = GameObject.Find("Debug Info").GetComponent<TextMeshProUGUI>();
    player = GameObject.Find("PlayerController").GetComponent<PlayerController>();
    waterObject = Instantiate(WaterPrefab, new Vector3(player.GetPosition().x, seaHeight, player.GetPosition().z), Quaternion.identity);

    CheckViewDistance(viewDistanceMax, viewDistanceMax);
  }

  bool IsChunkExists(Vector2 newP)
  {
    //buildList.Contains()
    /*
    for (int i = 0; i < buildList.Count; i++)
    {
      if (buildList[i] == newP)
        return true;
    }
    */
    if (buildList.Contains(newP))
      return true;

    /*
    for (int i = 0; i < createdList.Count; i++)
    {
      if (createdList[i] == newP)
        return true;
    }
    */
    if (createdList.Contains(newP))
      return true;

    return false;
  }

  void TryCreateChunkTo(int x, int y)
  {
    Vector2 newP = new Vector2(x, y);
    if (IsChunkExists(newP) == false)
      buildList.Add(newP);
  }

  void CheckViewDistance(int min, int max)
  {

    int distance = min / 2;
    Vector3Int p2 = playerInChunk * (int)MarchingData.width;


    for (int l = 0; l < distance; l += MarchingData.width)
    {
      for (int x = p2.x - l; x <= p2.x + l; x += MarchingData.width)
      {
        for (int y = p2.z - l; y <= p2.z + l; y += MarchingData.width)
        {
          if (x == p2.x - l || x == p2.x + l || y == p2.z - l || y == p2.z + l)
            TryCreateChunkTo(x, y);
        }
      }
    }

    //and destroy if chunk is too far away
    for (int i = createdList.Count - 1; i >= 0; i--)
    {
      Vector2 d = new Vector2(createdList[i].x, createdList[i].y);
      float dst = Vector2.Distance(d, new Vector2(p2.x, p2.z));
      if (dst > max)
      {

        Object.Destroy(chunkList[i].gameObject);
        createdList.RemoveAt(i);
        chunkList.RemoveAt(i);

      }
    }


    waterObject.transform.position = new Vector3(p2.x, seaHeight, p2.z);

    StartCoroutine(PopulateChunks());

  }

  // Update is called once per frame
  void Update()
  {

    Vector3Int newPos = player.GetChunkPosition();
    if (newPos.x != playerInChunk.x || newPos.z != playerInChunk.z)
    {
      playerInChunk = newPos;
      CheckViewDistance(viewDistanceMin, viewDistanceMax);
    }

    Vector3 p = player.GetPosition();
    debugText.text = string.Format("Chunk: {0},{1}\n", newPos.x, newPos.z);
    debugText.text += string.Format("Pos: {0},{1},{2}", (int)p.x, (int)p.y, (int)p.z);
  }

  IEnumerator PopulateChunks()
  {
    int counter = 0;
    while (buildList.Count > 0)
    {
      int x = (int)buildList[0].x;
      int z = (int)buildList[0].y;
      GameObject gob = Instantiate(MarchingCubePrefab, new Vector3(x, 0, z), Quaternion.identity);
      gob.transform.SetParent(chunkMaster.transform);
      gob.name = "chunk " + x + ", " + z;

      createdList.Add(buildList[0]);
      chunkList.Add(gob.GetComponent<Marching>());
      buildList.RemoveAt(0);
      counter++;

      if (counter > 2) {
        counter = 0;
        yield return null;
        
      }
    }
    player.locked = false;
  }

  void PopulateTextureArray()
  {
    terrainTexArray = new Texture2DArray(32, 32, terrainTextures.Length, TextureFormat.ARGB32, false);
    terrainTexArray.filterMode = FilterMode.Point;

    for (int i = 0; i < terrainTextures.Length; i++)
      terrainTexArray.SetPixels(terrainTextures[i].GetPixels(0), i, 0);

    terrainTexArray.Apply();

  }
}
