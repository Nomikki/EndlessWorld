using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class WorldGenerator : MonoBehaviour
{

  private static WorldGenerator _instance;
  public static WorldGenerator Instance { get { return _instance; } }
  public int worldSeed = 0;
  public Vector2Int randomOffset; //Generated by random seed.
  public TextMeshProUGUI debugText;
  public PlayerController player;


  //contains all chunks
  GameObject chunkMaster;

  public GameObject MarchingCubePrefab;
  public int viewDistanceMin = 256;
  public int viewDistanceMax = 256;
  public bool smoothTerrain = true;

  // our textures
  public Texture2DArray terrainTexArray;
  public Texture2D[] terrainTextures;

  // what need to build?
  List<Vector2> buildList = new List<Vector2>();
  Vector3Int playerInChunk;

  List<Vector2> createdList = new List<Vector2>();
  List<Marching> chunkList = new List<Marching>();

  private void Awake()
  {
    if (_instance != null && _instance != this)
      Destroy(this.gameObject);
    else
      _instance = this;

    PopulateTextureArray();
  }

  void OnDrawGizmosSelected()
  {
    Gizmos.color = new Color(1, 0.8f, 0, 0.2f);
    Vector3 p;
    Vector3 s = new Vector3(MarchingData.width, MarchingData.height, MarchingData.width);
    for (int i = 0; i < buildList.Count; i++)
    {
      p = new Vector3(buildList[i].x, 0, buildList[i].y) + (s / 2);
      Gizmos.DrawCube(p, s);
    }

    Gizmos.color = new Color(0, 0.8f, 2, 0.2f);
    for (int i = 0; i < createdList.Count; i++)
    {
      p = new Vector3(createdList[i].x, 0, createdList[i].y) + (s / 2);
      Gizmos.DrawCube(p, s);
    }

  }

  // Start is called before the first frame update
  void Start()
  {
    chunkMaster = GameObject.Find("Chunks");
    Random.InitState(worldSeed);
    randomOffset.x = Random.Range(0, 65000);
    randomOffset.y = Random.Range(0, 65000);

    debugText = GameObject.Find("Debug Info").GetComponent<TextMeshProUGUI>();
    player = GameObject.Find("PlayerController").GetComponent<PlayerController>();
    CheckViewDistance();

  }

  bool IsChunkExists(Vector2 newP)
  {
    bool foundOnCreatedList = false;

    for (int i = 0; i < createdList.Count; i++)
    {
      if (createdList[i] == newP)
      {
        foundOnCreatedList = true;
        break;
      }
    }
    return foundOnCreatedList;
  }

  void CheckViewDistance()
  {
    //buildList.Clear();
    int distance = viewDistanceMin / 2;
    Vector3Int p2 = playerInChunk * (int)MarchingData.width;

    for (int x = p2.x - distance; x < p2.x + distance; x += MarchingData.width)
    {
      for (int z = p2.z - distance; z < p2.z + distance; z += MarchingData.width)
      {
        Vector2 newP = new Vector2(x, z);
        if (IsChunkExists(newP) == false)
          buildList.Add(newP);
      }
    }



    Vector2 playerPos = new Vector2(p2.x, p2.z);
    //and destroy if chunk is too far away
    for (int i = createdList.Count - 1; i >= 0; i--)
    {
      Vector2 d = new Vector2(createdList[i].x, createdList[i].y);
      float dst = Vector2.Distance(d, playerPos);
      if (dst > viewDistanceMax)
      {

        Object.Destroy(chunkList[i].gameObject);
        createdList.RemoveAt(i);
        chunkList.RemoveAt(i);

      }
    }

    StartCoroutine(PopulateChunks());

  }

  // Update is called once per frame
  void Update()
  {

    Vector3Int newPos = player.GetChunkPosition();
    if (newPos.x != playerInChunk.x || newPos.z != playerInChunk.z)
    {
      playerInChunk = newPos;
      CheckViewDistance();


    }

    Vector3 p = player.GetPosition();
    debugText.text = string.Format("Chunk: {0},{1}\n", newPos.x, newPos.z);
    debugText.text += string.Format("Pos: {0},{1},{2}", (int)p.x, (int)p.y, (int)p.z);
  }

  IEnumerator PopulateChunks()
  {
    while (buildList.Count > 0)
    {

      int x = (int)buildList[0].x;
      int z = (int)buildList[0].y;
      GameObject gob = Instantiate(MarchingCubePrefab, new Vector3(x, 0, z), Quaternion.identity);
      gob.transform.SetParent(chunkMaster.transform);
      gob.name = "chunk " + x + ", " + z;

      createdList.Add(buildList[0]);
      chunkList.Add(gob.GetComponent<Marching>());
      buildList.RemoveAt(0);
      yield return null;
    }
    player.locked = false;
  }

  void PopulateTextureArray()
  {
    terrainTexArray = new Texture2DArray(32, 32, terrainTextures.Length, TextureFormat.ARGB32, false);
    terrainTexArray.filterMode = FilterMode.Point;

    for (int i = 0; i < terrainTextures.Length; i++)
      terrainTexArray.SetPixels(terrainTextures[i].GetPixels(0), i, 0);

    terrainTexArray.Apply();

  }
}
